lua实现继承问题
=============
1.实现继承链问题
	A,B,B继承与A,B的元表__index是A,B.super = A
	这样在
	B中明确调用A的方法是这样self.super.Afunc(self)
	b:init(),如果B有init将调用B的init,如果B没有就沿着继承链向上查找调用A的init

2.实现函数判断B是否从A继承,实现枚举继承链
	isKindOf( a,A ),通过类中加入两个字段,this自己的元表,super父类的元表
	
3.确保继承关系不能改变，就是super,this,是只读表
	setmetatable(B,{__index=A,__newindex=newindex})
	重新定义__newindex函数，是类表变为只读属性

加载跟新的问题
=============
问题在开始执行一个类时，在客户机上没有类代码也可能有过时的类代码。
这时要求启动一个界面进行加载，并且要求知道加载进度。一个类有父类链。
并且它还可能在代码中引用其他的类。
方案:
基本方法顺序加载，先下载自己然后下载父类以此类推。在执行过程中需要一个类
重复此过程。问题是没有下载进度，不知道加载还需要多长时间以及中间加载引用类
时的卡顿现象。因此这是一个完备但是体验不好的方案,需要对该方案进行优化。
1.加入一个依赖输入文件，例如叫depends.json，其中记录加载它需要的全部类列表，包括引用类。
	引入一种测试模式用来产生depends.json文件。可以在启动时加入一个特殊的参数来标记
	当前启动是为了收集需要加载类的列表。
2.在正式启动一个类前，加入一个启动界面（它也是一个类），将要加载的类列表传给它。
	如果产生import.json文件之后修改了某个它引用的类，那么系统也能执行，但是退化为没有优化
	的模式。
	
对象类多个脚本文件应用问题
========================
在一个对象类中有多个脚本文件，例如主脚本叫main.lua，它引用一个test.lua。
lua将在luacore中查询test.lua文件。而不是在main.lua平行路径中查询。
目前没有太好的解决办法,只能给出完整的路径名称。
local test = require "class/classid/test"
假想的方法是这样local test = require "test"，但是查找顺序是先同级路径，然后在luacore。
但是没有办法为对象类定制私有的require方法。

对象类的super实现(在类中加入特定变量，甚至改变类的语义)
================

